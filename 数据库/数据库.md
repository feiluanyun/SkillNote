#数据库操作关系
***
###关系数据库
>一条数据称作记录,各个项目称作字段
>能够确定数据的列叫做主键
>关系数据库能够使用表格来处理数据
>关系数据库可以基于数学运算
####并
> 抽取包含表一和表二所有商品
####差
> 调取表一表二中一张表格独有的商品
####交
> 调取表一表二两张表格都存在的商品
####笛卡儿积
>将两个表格中所有排列组合的方法
####投影
> 调取表中某一列的运算
####选择
> 调取表中某行的运算
####连接
> 关系数据库,参考其他表格中的列
> 外键参照其他表中的主键时,通过连接,可以将两个表格粘合
####除
> 从"被除表格"中调取"除表格"中包含的所有行,再从中去掉"除表格"中所有行的运算
###设计数据库

####E-R模型
>使用E-R模型的分析，从现实中抽取实体，从实体入手就容易分析对象

>编码王国的水果出口到多个国家，每个国家进口多种水果，通过E-R模型分析出水果和出口国之间的存在着多对多的关系，认为是m种水果对应n个出口国，这种实体对应关系称为基数。

#####E-R模型分析方法
######一对一的关系
>一个出口国管理一个一个出口信息
######一对多的关系
>一个公主有多个仆人
######多对多的关系
>水果销往多个出口国,出口国购买多种水果
####表格规范化

>未分割的表格一行有两个以上的数值,称为非范式。
>>[图片]

>单纯将表格分割为单纯的二元表格,称为第二范式
>[图片]

>主键的值可以确定其他列的值，按照这一原则分割的表格称为第二范式
>>[图片]

>由主键唯一确定其他列的表格叫做第三范式
>>[图片]
####设计数据库
#####概念模式
>将现实生活模型化的阶段进阶进而,是确定数据库理论结构的阶段
#####内部模式
>从计算机内部看到的数据库,是确定数据库物理构造的阶段.
#####外部模式
>是从用户和应用的角度来观察的数据库
>外部模式设计是通过设计应用程序所必要的数据来实现.
####小结
* E-R模型用来分析实体和关系
* 实体之间的关系数分为一对一,一对多和多对多
* 关系数据库的表格有必要规范化
* 关系数据库的设计分为概念模式,内部模式和外部模式三个部分
***
###SQL的基本操作
####SQL的功能
* 制成数据库结构
* 操作数据库中的数据
* 控制数据库
####使用select命令检索
```sql
select * from 商品 where 单价=200;
```
####使用比较运算符设定条件
```
= > >= < <= 
<>不等于
```
####使用逻辑运算符制作条件
```
AND OR NOT
```
####使用通配符
> %表示任意字符串
> _表示一个字符串
####能够进行各种检索
```sql
select *
from 商品
where 单价
between 150 and 200;
```
> 调取单价在150~200的商品
***
```sql
select *
from 商品
where 单价 is null;
```
>能够检索空值
####使用计算函数计算
```sql
select count(*)
from 商品
where 单价>=200;
```
> 统计单价在200G以上的商品行数.
####分组计算
```sql
select 地域, AVG(单价)
from 商品
group by 地域;
```
> 求每个地域的商品数和平均单价,使用分组化功能和计算函数结合.
***
```sql
select 地域, AVG(单价)
from 商品
group by 地域
having avg(单价)>=200;
```
> 使用having来设定条件,抽取平均单价在200G以上的地域.
####计算与分组化
######Q7人口最少的国家有多少万人
```sql
SELECT MIN(人口)
from 出口国
```
######Q8人口最多的国家有多少万人
```sql
SELECT MAX(人口)
from 出口国
```
######Q9出口国中所有国家人口总和是多少万人
```sql
SELECT SUM(人口)
from 出口国
```
######Q10出口国编码为20以上的所有国家人口总和
``` sql
SELECT SUM(人口)
from 出口国
where 出口国编码>=20
```
######Q11人口在100万以上的国家
```sql
SELECT COUNT(人口)
from 出口国
where 人口>=100
```
######Q12地处北洋的国家
```sql
SELECT COUNT(地域)
from 出口国
where 地域='北洋'
```
######Q13地处北洋的国家中人口最多的国家有多少万人
```sql
SELECT max(人口)
from 出口国
where 地域='北洋'
```
######Q14除理托儿王国外,其他国家人口总和是多少万人
```sql
SELECT SUM(人口)
from 出口国
where 出口国名称!='理托儿'
```
######Q15平均人口在两百万的地域
```sql
SELECT 地域, avg(人口)
from 出口国
GROUP BY 地域
HAVING avg(人口)>=200
```
######Q16拥有三个国家以上的地域
```sql
SELECT 地域, COUNT(地域)
from 出口国
GROUP BY 地域
having COUNT(地域)>=3
```
####使用子查询
在查询中嵌套其他查询,这种查询叫做子查询
######检索数量在1000以上的商品名称
```sql
SELECT * FROM 商品
WHERE 商品编码 IN
(SELECT 商品编码
FROM 销售明细
WHERE 数量>=1000);
```
####使用相关子查询进行检索
在子查询中,内部查询也可以使用外部指定的表格,这叫做相关子查询.
######抽出比每个符合条件的商品大于平均数量的商品明细
```sql
SELECT * 
FROM 销售明细 u
WHERE 数量 >
(SELECT AVG(数量)
FROM 销售明细
WHERE 商品编码 = u.`商品编码`);
```
######Q17 单价在300G以上的水果的销售明细
```sql
SELECT * 
FROM 销售明细 
WHERE 商品编码 IN
(SELECT 商品编码
FROM 商品
WHERE 名称单价>=300);
```
######Q18 每种商品的平均销售数量
```sql
SELECT *
FROM 销售明细 u
WHERE 数量< 
(SELECT AVG(数量)
FROM 销售明细
WHERE `商品编码`=u.`商品编码`);
```
####各种各样的连接
######inner join
>仅选择数值相同的行进行连接
######left join or right join
>全部保留任何一方表格的所有行,将一方中没有的行设置为空值的连接方式称为外部连接.
####制作表格
######CREATE TABLE 命令
```sql
CREATE TABLE 商品
(
    商品编码 number(3,0),
    商品名称 char(20),
    单价 number(10,0),
    PRIMARY KEY(商品编码)
);
```
|限制|含义|
|:---:|:---:|
PRIMARY KEY|设定关键词
UNIQUE|唯一
NOT NULL|不许出现空值
CHECK|检查范围
DEFAULT|设定默认值
FOREING KEY/REFERENCES|设定外关键词

####插入,更新,删除数据
>数据的插入,更新,删除操作必须遵循约束条件
######添加数据
```sql
INSERT INTO 商品(商品编码,商品名称,单价)
VALUES (202,"枇杷",200);
```
######更新数据
```sql
UPDATE 商品
SET 商品名称 = "甜瓜"
WHERE 商品名称="香瓜";
```
######删除数据
```sql
DELETE FROM 商品
WHERE 商品名称="苹果";
```
####制作视图
>输入数据的表格称为基本表
```sql
CREATE VIEW 高价商品(商品编码,商品名称,单价)
AS SELECT *
FROM 商品
WHERE 单价>=200;
```

```sql
SELECT *
FROM 高价商品
WHERE 单价 >= 500;
```

####管理表格和数据中问题
######Q19使用CREATE TABLE 制作'出口国'表.添加以下四条数据
```sql
CREATE TABLE 出口国
(
    出口国编码 int(3),
    出口国名称 VARCHAR(20),
    人口 int(10),
    地域 VARCHAR(20)
);
INSERT INTO 出口国(出口国编码,出口国名称,人口,地域)
VALUES(12,'米纳米王国',100,'南洋'),
(15,'帕罗努国',200,'中部'),
(22,'托康塔国',160,'北洋'),
(23,'阿尔法帝国',120,'北洋');
```
######Q20从地处北洋的国家,制作'北洋诸国'视图
```sql
CREATE VIEW 北洋诸国(出口国编码,出口国名称,人口)
AS SELECT 出口国编码,出口国名称,人口
FROM 出口国
where 地域='北洋';
```
######Q21将"出口国"表中托康塔国的人口更改为150万人
```sql
UPDATE 出口国
SET 人口='150'
WHERE 出口国名称='托康塔国';
```
######Q22将'出口国'表中帕罗努国的数据删除
```sql
DELETE FROM 出口国
WHERE 出口国名称='帕罗努国';
```
####在应用程序中使用SQL
>在程序语言使用SQL的方式有很多种,编译程序是预置的SQL命令的静态SQL以及执行程序时送出SQL命令的动态SQL.
>在使用程序语言java时,通过准备动态SQL相应的驱动,可以访问,查询数据库.
####小结
* SQL具有数据定义功能,数据操作功能和数据约束功能.
* 检索数据时使用SELECT命令
* 指定条件时使用WHERE命令
* 插入,更新,删除数据时使用INSERT,UPDATE,和DELETE命令
* 制作表格时使用CREATE TABLE 命令
***
###数据库的应用
####了解事务的性质
>用户的一个连贯操作称为数据库事务
######数据库事务属性
性质|内容|含义
:---:|:---:|:---:|
A|原子性|数据库事务必须结束于提交或回滚中的任意一个任务
C|一致性|执行数据库事务时不能损坏数据库的一致性
I|隔离性|两个事务的执行是互不干扰的,一个事务不可能看到其他事务运行时,中间某一时刻的数据
D|持久性|在事务完成之后,该事务对数据库所作的更改便持久的保存在数据库之中,并不会回滚
####使用提交或回滚来结束
>为了使数据库操作中不发生矛盾,数据库事务必须由提交或者回滚中的任意一个指令来结束.
```sql
/*提交*/
commit
/*回滚*/
rollback
```
* Q1写出确定数据库事务时的SQL命令
```sql

```
* Q2写出取消数据库事务时的SQL命令
```sql

```
####数据不发生矛盾
 > 数据库事务执行前数据库不存在矛盾,操作执行后数据库也不能存在矛盾
 > 事务即使并列访问相同资源,也不会发生矛盾.
####通过锁进行控制
>数据库事务的隔离性要求安排必须可序列化
>读取数据时使用共享锁,写入数据时使用独占锁

>使用共享锁,其他事务可以加共享锁,但不能加独占锁;
>使用独占锁时,无论是共享锁还是独占锁,其他事务都不可以加锁.

共享锁和独占锁关系
|&nbsp;|共享锁|独占锁|
|:---:|:---:|:---:|
共享锁|●|?|
独占锁|?|?|

####使用两相锁确保可序列化
>确保数据库事务可序列化过程中,对于锁的设定和解除需要遵守一定的规则,其中一项就是两相锁
####注意锁的粒度
>增大锁的粒度,每个事务加设锁的次数降低,可以减少管理锁的工作量,但由于加锁的对象广泛,等待解除其他加锁事务的时间会很长,同时可以执行的事务就减小了.
>减小锁的粒度,每个事物加设锁的次数增加,增加了管理锁的工作量,但由于加锁的对象范围窄,等待解除其他加锁事务的时间也就减少了,可执行事务数增加了.
####其他同时执行控制
######时间戳控制
>事务给每个被访问的数据打上时间戳,
>指某个事务要读写这个数据时,比这个事务拥有更早时间戳的事务更新了数据的情况下,不允许读写数据,不许读写情况下,回滚此事务.
######乐观控制
>从写入点开始,确认是否由其他事务更新数据.若有其他事务更新了数据,则回滚.
####隔离级别的设置
>能够逐渐控制事务之间互相干扰的级别叫做隔离级别.
* 脏读:事务1在提交前事务2读取该行,在事务1回滚的情况下,事务2读取了不存在的行.
* 非重复读:事务1读取行时,事务2在更新该行并提交时,事务1再一次读取该行发生数值不一致.
* 虚读:事务1进行检索,获得多行结果,事务2追加了符合该条件的行,事务1第二次检索结果发生不同的现象.
>未设定隔离级别的情况下,默认为SERIALIZABLE

|&nbsp;|脏读|非重复读|虚读|
|:--:|:--:|:--:|:--:|
|READ UNCOMMI TTED|可能发生|可能发生|可能发生
|READ COMMITTED|不发生|可能发生|可能发生|
|REPEAATABLE|不发生|不发生|可能发生
|SERIALIZABLE|不发生|不发生|不发生

####数据库的安全问题
######GRANT命令 给予用户操作权限
```sql
GRANT SELECT, UPDATE ON 商品 TO 外国部;
```
|&nbsp;|权限示例|
|:--:|:--:|
SELECT|检索表格中行的权限
INSERT|向表格中插入行的权限
UPDATE|更新表格中行的权限
DELETE|删除表格中行的权限
ALL|所有权限

######WITH GRANT OPTION授予权限
```sql
GRANT SELECT, UPDATE ON 商品 TO 外国部 WITH GRANT OPTION
```

######REVOKE命令收回权限
```sql
REVOKE SELECT, UPDATE ON 商品 TO 外国部;
```
>抽取基本表的一部分制作可视表,通过设定对该表可视表的权限,能够实现设定访问表格中部分数据的权限.进行安全设定对于保护数据库中的数据是非常重要的.

####使用索引进行快速检索
>索引方法
> * B树
> * 散列
######B树
> B树中每个节点可以有多个子数据,从而控制树的高度,即使有很多数据,从根部找也能很快找到存放地址,除根节点外,其他节点拥有的子数据最多为2n个,最少为n个.

######散列
>散列是对数据键值对运用散列函数,求得存储地址的方法
>散列用于'101'这种完全一致检索时功能强劲,不适合'101以上'这种比较条件检索和"末尾带'子'的商品"这样的模糊检索.

####最优化查询
```sql
SELECT 日期,商品名称
FROM 商品,销售
WHERE 单价>=200
AND 商品.商品编码=销售.商品编码
```
> 一般来说按照
> * 先行执行选择减少行数
> * 再执行投影减少与结果无关的列
> * 最后执行连接

######连接方式有以下几种
1. 嵌套循环
   > 从表一中抽取一行,表二中列值与之比较是否相同,相同情况下,将作为结果生成连接后的行
2. 分类合并
   > 将表一和表二全部或者部分分类,从第一行开始检查,值相同时作为结果生成连接后的行,由于要进行分类,进行一个方向的处理就够了,处理时间非常短,但是要注意先行分类花费的时间.
3. 散列
   >将一个表格根据散列函数进行分割,与另一个表格中具有相同散列值的行进行连接,这种方法求取连接行的效率很高
######最优化标准
* 规则导向
  >预先确定多个规则,按照规则决定的优先顺序选择方法的方式
* 成本导向
  >定期生成数据分布等统计信息,再根据这些信息进行选择的方式.
####故障恢复
* 事务故障
  >因为事务不完备而导致事务不能结束的情况.在事务故障中,发生故障的事务将被回滚.
* 系统故障
  >因停电等原因造成系统停运,通常对故障发生时未提交的事务进行回滚,对故障发生时已提交的事务进行前卷
* 介质故障
  >指硬盘损伤的情况,发生时,可以基于备份文件进行故障恢复,对备份后提交的事务进行前卷处理.
####检查点和恢复

>为提高写入效率,多采用暂时将数据写入缓存的方法,采用这种方式,检查时对已提交的事务不必进行故障恢复,检查时未提交的事务才是故障恢复的对象.

####小结
* 能够设定数据库用户的权限
* 同时执行控制方法-----锁
* 通过生成索引能够进行高速检索
* 数据库具备故障恢复功能

####数据库的普及和灵活应用
######分布式数据库中表格连接
* 嵌套循环
  > 将服务器A中表格的某行发送到服务器B,与服务器B中表格的每一行进行比较后连接,如此反复操作.
* 分类合并
  >将各服务器表格预先分类,将服务器AB的表格各自分类,因为事前已经分类,能够通过一个方向的读取进行连接.
* 半连接
  >将与连接相关的列发送与之连接的服务器,在减少行之后进行连接的方法.
* 散列半连接
  >先求取服务器A中列的散列值,并发送到服务器B,在服务器中也求取散列值,通过散列值之间的检查进行连接.

####复制的配置
>为了减少网络的负担,设置了复制的功能,通过重复使用数据的复制,减少了网络中传送的数据
######复制的方式
*  读取专用
  >一种生成并下载从主服务器的主数据库中读取专用复制的方法,复制在主服务器连接时生成,复制仅可读取.
*  可更新主服务器
  >从主服务器生成复制,该复制能够更新,更新复制时被反应在主服务器的主数据库中.
*  可更新各个服务器
  >各个服务器之间拥有相同主服务器的方法.在各个服务器中更新后,可反应在其他服务器的数据库中.
####数据库的深层次应用
 * XML
 * OODB
  
####小结
* 构成Web系统的方法-三层客户端・服务器系统
* 数据库使用数据层
* 分布式数据库处理分散了的数据库
* 俩阶段提交用于分布式数据库

###常用SQL命令
####基本检索
```sql
SELECT 列名,...
FROM 表格名称
WHERE 条件;
```
####模糊检索
```sql
SELECT 列名,...
FROM 表格名称
WHERE 列名 LIKE "样式";
```
####排列
```sql
SELECT 列名,...
FROM 表格名称
WHERE 条件;
ORDER BY 列名;
```
####合计 分组化
```sql
SELECT 列名,...
FROM 表格名称
WHERE 条件
GROUP BY 分组列名
HAVING 分组行的条件;
```
####表格的连接
```sql
SELECT 列名,...
FROM 表格名称1,表格名称2,...
WHERE 表格名称1.列名=表格名称2.列名;
```
####生成基本表
```sql
CREATE TABLE 表格名称(
    列的定义
    ......
);
```
####生成可视化
```sql
CREATE VIEW 可视化名称
AS SELECT命令;
```
####删除基本表
```sql
DROP TABLE 表格名称;
```
####删除可视表
```sql
DROP VIEW 可视化名称;
```
####插入行
```sql
INSERT INTO 表格名称(列名,......) VALUES(值,......);
```
####更新行
```sql
UPDATE 表格名称
SET 列名 = 值,......
WHERE 条件;
```
####删除行
```sql
DELETE FROM 表格名称
WHERE 条件;
```
***

来源:漫画数据库,(日)高桥麻奈